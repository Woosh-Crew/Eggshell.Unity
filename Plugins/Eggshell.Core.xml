<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eggshell.Core</name>
    </assembly>
    <members>
        <member name="T:Eggshell.Bootstrap">
            <summary>
            Bootstrap is responsible for initializing all eggshell modules for your
            application as well as responsible for controlling them. This is overrideable
            so you can use this in existing applications / frameworks / engines incredibly easy.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.#ctor">
            <summary> 
            Creates a new instance of the bootstrap class. This should 
            be only constructed one  and used in the Project.Crack to
            initialize your application.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.Ready">
            <summary>
            Invoke ready, to run the OnReady call chain on all modules. You
            can override this on the OnBooted method. 
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.Focus(System.Boolean)">
            <summary>
            Invoke ready, to run the OnFocus call chain on all modules. You
            can override this on the OnFocus method. Make sure to call this
            in your own bootstrap, as its not called by default! 
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.Update">
            <summary>
            Invoke Update, to run the update loop on all modules, you
            can override this by overriding the protected method OnUpdate;
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.Shutdown">
            <summary>
            Invoke Shutdown, to run the shutdown call chain on all modules, you
            can override this by overriding the protected method OnShutdown
            </summary>
        </member>
        <member name="T:Eggshell.Bootstrap.Callbacks">
            <summary>
            Callbacks specific for the bootstrap, these mostly only get called as
            the project is bootstrapping. great for injecting high level logic into
            low level code, or for pissing off modules you dont need in your project
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.Callbacks.OnModule(Eggshell.IModule)">
            <summary>
            Everytime a module requests to be created, it'll call this. So you
            can override which modules are meant to be initialized at a bootstrap
            level. Incredibly useful for removing modules, without breaking anything;
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnStart">
            <summary>
            OnStart is called by Boot() before any of the modules have been
            initialized. Use this for doing pre-initialization.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnModules">
            <summary>
            Override OnModules to change how modules are cached and registered.
            You should never need to override this, but just in case it is.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnBooted">
            <summary>
            Called when eggshell is ready, and the bootstrap has done what it
            needs to do. This should call OnReady on all modules, so they can
            start there systems.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnFocus(System.Boolean)">
            <summary>
            Called when the application changes its focus. Tells all the modules
            that the focus has changed.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnUpdate">
            <summary>
            The update loop for your application, by default this will call
            the OnUpdate method on modules. Shouldn't need to override this.
            </summary>
        </member>
        <member name="M:Eggshell.Bootstrap.OnShutdown">
            <summary>
            Called when the application is quitting / shutting down. Use this
            to dispose any bootstrap specific resources. Should call OnShutdown
            on all modules. 
            </summary>
        </member>
        <member name="T:Eggshell.Client">
            <summary>
            A Client in Eggshell is a person / the idea of someone using the
            application. We use client's in the context of networking, possession,
            authority, etc. Clients are a good way to abstract logic between people. 
            </summary>
        </member>
        <member name="T:Eggshell.IPossessable">
            <summary>
            An Object having this interface allows it to be possessed by
            a client. Allowing a client to have authority over it.
            </summary>
        </member>
        <member name="M:Eggshell.IPossessable.OnPossess">
            <summary>
            A callback for when a client takes authority over the
            object.
            </summary>
        </member>
        <member name="M:Eggshell.IPossessable.OnUnpossess">
            <summary>
            A callback for when a client doesnt have authority over the
            object any more.
            </summary>
        </member>
        <member name="T:Eggshell.Components`1">
            <summary>
            A Simple components database container, that easily allows any class to have a set of 
            components, that can easily be accessed at anytime. Great for dependency injection
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.#ctor(`0)">
            <summary>
            Creates an new components database. This should be done in your classes
            constructor, so there always is a database.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.#ctor(`0,System.Collections.Generic.List{Eggshell.IComponent{`0}})">
            <summary>
            Creates an new components database with a inputted list, useful for
            when you want to have control over the list (say for networking). This
            should be done in your classes constructor, so there always is a database.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Finalize">
            <summary>
            Clears all the components from the registry when it is deconstructed, to
            make sure no logic gets fucked up (Might not? not sure, just in-case)
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Add``1(``0)">
            <summary>
            Adds a component to the components registry, checks if its a singleton
            component, if was replaces old with new.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Contains(Eggshell.IComponent{`0})">
            <summary>
            Checks if the components database already contains that component.
            returns true if it is in it.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Remove(Eggshell.IComponent{`0})">
            <summary>
            Detaches and removes a component from the components database. 
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Clear">
            <summary>
            Detaches and removes all components from the components database.
            Make sure to call this on deconstruction!
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Detach(Eggshell.IComponent{`0})">
            <summary>
            Detaches a component from the registry / database. Used internally
            so users cant fuck up they shit.
            </summary>
        </member>
        <member name="P:Eggshell.Components`1.Count">
            <summary>
            Gets the number of components that have been registered to this components
            database, use in conjunction with the indexer.
            </summary>
        </member>
        <member name="P:Eggshell.Components`1.Item(System.Int32)">
            <summary>
            A Simple array index accessor for the Components, so you can iterate
            over them without collecting garbage from IEnumerable.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Get``1">
            <summary>
            Gets a component from the database based off the inputted type of T.
            Caches the result so you can do prototype shit, without the performance
            cost.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Get(System.Type)">
            <summary>
            Gets a component from the database based off the inputted type. Only checks
            if the types match, Not if its a subtype of the type
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Create``1">
            <summary>
            Creates and adds a component to the components registry. Great for quickly
            adding components that have a parameterless constructor
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Replace``1(Eggshell.IComponent{`0},``0)">
            <summary>
            Replaces a component with a new component, by removing the old form the database
            and then adding the new one.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Replace``2">
            <summary>
            Replaces a component with a new component, by removing the old form the database
            and then adding the new one.
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.TryGet``1(``0@)">
            <summary>
            Trys to get the component of type T, and returns true if it could be found. Spews
            the out parameter with the found component, or else it is null
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.TryGet(System.Type,Eggshell.IComponent{`0}@)">
            <summary>
            Trys to get the component of type that is inputed, and returns true if it could
            be found. Spews the out parameter with the found component, or else it is null
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Has``1">
            <summary>
            Checks to see if the database contains the inputted type of T. (Behind the scenes
            it gets the components, and returns if it was null or not)
            </summary>
        </member>
        <member name="M:Eggshell.Components`1.Has(System.Type)">
            <summary>
            Checks to see if the database contains the inputted type. (Behind the scenes
            it gets the components, and returns if it was null or not)
            </summary>
        </member>
        <member name="T:Eggshell.Archive">
            <summary>
            An archive is a statically typed file. We use this in conjunction
            with the library system to get types based on their extension.
            </summary>
        </member>
        <member name="P:Eggshell.Archive.Fallback">
            <summary>
            What file should we load by default if loading one failed.
            </summary>
        </member>
        <member name="P:Eggshell.Archive.Extension">
            <summary>
            The default extension for this archive.
            </summary>
        </member>
        <member name="P:Eggshell.Archive.Serialization">
            <summary>
            The serialization type for this archive.
            </summary>
        </member>
        <member name="T:Eggshell.Files">
            <summary>
            Files, is Espionage.Engines File System.
            All Saving, Loading, ETC. You can use
            short hands for defining paths.
            </summary>
        </member>
        <member name="M:Eggshell.Files.Save``1(Eggshell.Library,``0,System.String)">
            <inheritdoc cref="M:Eggshell.Files.Save``1(``0,System.String)"/>
        </member>
        <member name="M:Eggshell.Files.Save``1(``0,System.String)">
            <summary>
            Saves anything you want, (provided theres a
            serializer for it) to the given path
            </summary>
        </member>
        <member name="M:Eggshell.Files.Save``1(Eggshell.Library,``0[],System.String)">
            <inheritdoc cref="M:Eggshell.Files.Save``1(``0,System.String)"/>
        </member>
        <member name="M:Eggshell.Files.Save``1(``0[],System.String)">
            <summary>
            Saves an array of anything you want,
            (provided theres a serializer for it)
            to the given path
            </summary>
        </member>
        <member name="M:Eggshell.Files.Delete(Eggshell.IO.Pathing)">
            <summary>
            Deletes the file at the given path
            </summary>
        </member>
        <member name="M:Eggshell.Files.Delete(Eggshell.IO.Pathing,System.String)">
            <summary>
            Deletes all files with the given extension at the path
            </summary>
        </member>
        <member name="M:Eggshell.Files.Delete(Eggshell.IO.Pathing,System.String[])">
            <inheritdoc cref="M:Eggshell.Files.Delete(Eggshell.IO.Pathing,System.String)"/> 
        </member>
        <member name="M:Eggshell.Files.Copy(Eggshell.IO.Pathing,Eggshell.IO.Pathing,System.Boolean)">
            <summary>
            Copies the source file or directory to the target path
            </summary>
        </member>
        <member name="M:Eggshell.Files.Move(Eggshell.IO.Pathing,Eggshell.IO.Pathing)">
            <summary>
            Moves the source file to the target destination
            </summary>
        </member>
        <member name="M:Eggshell.Files.Open(Eggshell.IO.Pathing)">
            <summary>
            Opens the given directory in the OS's File Explorer,
            or opens the given file in the default application
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Shorthand.Find(System.String)">
            <summary>
            Tries to find a shorthand that matches the key, then returns one. This
            can return default.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Add(System.String,System.String)">
            <summary>
            Add a shorthand / virtual path to the pathing database
            for use later. You can add to already exising keys.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Add(System.String,System.Func{System.String[],System.String})">
            <summary>
            Add a keyword to the pathing database for use later, 
            you can't override already exising keys.
            The string[] are optional parameters you can include
            into the Keyword, they are divided by a comma.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Absolute(System.Boolean)">
            <summary>
            Gets the Path, If you use the virtual pathing
            It'll search loaded mods first then the base content,
            Depending on the virtual path you are trying to get.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Create">
            <summary>
            Creates a directory at the given path
            if the directory didnt exist.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Relative(Eggshell.IO.Pathing)">
            <summary>
            Gets the path, relative to another path. If you use
            the virtual pathing It'll search loaded mods first
            then the base content, Depending on the virtual
            path you are trying to get.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Virtual">
            <summary>
            Converts this pathing to be virtual path. Useful for loading over
            the network, where files would be relative to a shorthand
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Normalise">
            <summary>
            Makes all directory separator chars the same, makes all text lower case
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Meta">
            <summary>
            Gets the files meta at the given path.
            Meta includes its attributes, when it was
            created, the lsat access time and the last
            write time.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsValid">
            <summary>
            Checks if this path is a valid path. Meaning it'll check
            if it is a string that could potentially lead to a path. 
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsVirtual">
            <summary>
            Checks if a path is a virtual path (Meaning it is relative to a shorthand)
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsEmpty">
            <summary>
            Checks if the path is empty or null 
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.InFolder(System.String,System.String)">
            <summary>
            Is this path or file in a folder named "x"?
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsRelative">
            <summary>
            Checks if the current path is rooted
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsRooted">
            <summary>
            Does this path come from a drive?
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsAbsolute">
            <summary>
            Checks if the current path is a full valid path
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsDirectory">
            <summary>
            Checks if the current path is a directory
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.IsFile">
            <summary>
            Checks if the current path is a file
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Exists">
            <summary>
            Will check if the File or Directory exists
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.All(System.Boolean,System.IO.SearchOption)">
            <summary>
            Gets all directories or files at the given path with the
            following search option
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.All(System.IO.SearchOption,System.String[])">
            <summary>
            Gets all files at the current scoped directory with the given extensions 
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Hash">
            <summary>
            Fast Hashes this path for use over network
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Name(System.Boolean)">
            <summary>
            Gets the name of last directory or file
            at the given path
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Extension">
            <summary>
            Gets the name of last directory or file
            at the given path
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathing.Info``1">
            <summary>
            Gets the FileSystemInfo type
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Store(System.Byte[],Eggshell.IO.Pathing)">
            <summary>
            Saves a byte buffer to a path,
            it will overwrite if the file at that
            path already exists.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Serialize``1(``0)">
            <summary>
            Serialize type of T to a byte array.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Serialize``1(Eggshell.Library,``0)">
            <summary>
            <para>
            <inheritdoc cref="M:Eggshell.IO.Serializer.Serialize``1(``0)"/>
            </para>
            <para>
            This is faster, if you already have the lib.
            </para>
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Serialize``1(``0[])">
            <summary>
            Serialize an type array of T to a byte array.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Serialize``1(Eggshell.Library,``0[])">
            <summary>
            <para>
            <inheritdoc cref="M:Eggshell.IO.Serializer.Serialize``1(``0)"/>
            </para>
            <para>
            This is faster, if you already have the lib.
            </para>
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Deserialize``1(System.String)">
            <summary>
            Deserializes data at the given path. Will
            automatically deserialize it to the target
            format.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Deserialize``1(Eggshell.Library,Eggshell.IO.Pathing)">
            <summary>
            <para>
            <inheritdoc cref="M:Eggshell.IO.Serializer.Deserialize``1(System.String)"/>
            </para>
            <para>
            This is faster, if you already have the lib.
            </para>
            </summary>
        </member>
        <member name="M:Eggshell.IO.Serializer.Deserialize(Eggshell.IO.Pathing)">
            <summary>
            Just gives us the raw data from a file at a path
            </summary>
        </member>
        <member name="T:Eggshell.IO.Pathable">
            <summary>
            Registers a Path to be unusable in the pathing system. is used like 
            {Short://}.
            </summary>
        </member>
        <member name="P:Eggshell.IO.Pathable.Short">
            <summary>
            The Shorthand that is used when registering the path and then 
            used like this "{value}://", excellent for quickly getting the path
            of something, without knowing where it actually is.
            </summary>
        </member>
        <member name="P:Eggshell.IO.Pathable.Full">
            <summary>
            The full path that the short path maps too, you can nest short paths 
            in this full path. They will unravel when asking for the path.
            </summary>
        </member>
        <member name="M:Eggshell.IO.Pathable.#ctor(System.String,System.String)">
            <summary>
            Sets up the component, Hand = Shorthand, Full = Absolute path that allows
            nested shorthand. 
            </summary>
        </member>
        <member name="T:Eggshell.IObject">
            <summary>
            Stores class information, used for networking, meta data, etc.
            Which can be accessed in the Library.Database
            </summary>
        </member>
        <member name="P:Eggshell.IObject.ClassInfo">
            <summary>
            ClassInfo holds this classes meta data, that is stored in the Library Cache.
            Library stores all Meta Data relating to this current class,
            such as Functions, Properties, Groups, Components, etc.
            </summary>
        </member>
        <member name="M:Eggshell.IObject.Delete">
            <summary>
            Deletes this object from the library registry. Override this to call
            additional logic when deleting an IObject object.
            </summary>
        </member>
        <member name="T:Eggshell.Converter">
            <summary>
            Eggshell's string to object converter. Converts objects by looking for a valid
            converter using the reflection system, creates it and calls its convert method.
            </summary>
        </member>
        <member name="M:Eggshell.Converter.Convert``1(System.String)">
            <summary>
            Converts a string to the type of T. Uses eggshells reflection system to find
            the correct converter, and uses it to convert the string to T.
            </summary>
        </member>
        <member name="M:Eggshell.Converter.TryConvert``1(System.String,``0@)">
            <summary>
            Trys to convert a string to the type of T. Uses eggshells reflection system to
            find the correct converter, and uses it to convert the string to T. Returns false
            if it failed to convert.
            </summary>
        </member>
        <member name="M:Eggshell.Converter.Convert(System.String,System.Type)">
            <summary>
            Converts a string to an object. Based off the inputted type. Does use a little
            bit of reflection, which might reflect on its performance.
            </summary>
        </member>
        <member name="M:Eggshell.Converter.TryConvert(System.String,System.Type,System.Object@)">
            <summary>
            Trys to converts a string to an object. Based off the inputted type. Does use a
            little bit of System.Reflection, which might reflect on its performance. Returns
            false if it failed to convert.
            </summary>
        </member>
        <member name="T:Eggshell.Dispatch">
            <summary>
            Fire and forget message dispatching. Primarily used for invoking
            methods from a string (string based events) can be used across
            languages. (C# - C++, vice versa)
            </summary>
        </member>
        <member name="P:Eggshell.Dispatch.Provider">
            <summary>
            The underlying system that controls the dispatcher. Override
            this to add your own dispatching logic.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatch.Run(System.String)">
            <summary>
            Runs a fire and forget dispatch. Incredibly useful for global
            events, where you don't need to create boiler plate code to setup 
            </summary>
        </member>
        <member name="M:Eggshell.Dispatch.Run(System.String,System.Object[])">
            <summary>
            Runs a dispatch with an array of args. Use this with caution
            as it creates an array with the args.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatch.Register``1(``0)">
            <summary>
            Registers an instanced IObject to receive dispatch events.
            (Make sure to unregister the object when finished, or else
            it wont be collected by the GC)
            </summary>
        </member>
        <member name="M:Eggshell.Dispatch.Unregister``1(``0)">
            <summary>
            Unregisters an instanced IObject from the dispatch system.
            (Make sure to call this after you're finished with a registered
            object, or else the GC wont collect it)
            </summary>
        </member>
        <member name="T:Eggshell.Dispatching.IDispatcher">
            <summary>
            IDispatcher is responsible for providing a binder / logic
            provider to the Dispatcher itself. This allows you to override
            how the dispatcher works.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatching.IDispatcher.Add(System.String,Eggshell.Reflection.Function)">
            <summary>
            Add this function to the event stack using this string as
            the id it should be invoked from
            </summary>
        </member>
        <member name="M:Eggshell.Dispatching.IDispatcher.Run(System.String)">
            <summary>
            Send out a dispatch by its string id / name without any
            parameters.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatching.IDispatcher.Run(System.String,System.Object[])">
            <summary>
            Send out a dispatch by its string id / name with an array
            of parameters.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatching.IDispatcher.Register(Eggshell.IObject)">
            <summary>
            Register this object to receive instance based dispatch
            messages from the dispatcher.
            </summary>
        </member>
        <member name="M:Eggshell.Dispatching.IDispatcher.Unregister(Eggshell.IObject)">
            <summary>
            Unregister this object to no longer receive dispatch messages,
            make sure to call this when destroying an object, or else GC
            wont clean it up as it still has references
            </summary>
        </member>
        <member name="T:Eggshell.IModule">
            <summary>
            Modules are automatically created by eggshell from the bootstrap
            on application startup (when you crack the egg). Modules allow incredibly
            easy dependency injection, as well as easily creating scalable applications 
            </summary>
        </member>
        <member name="M:Eggshell.IModule.OnRegister">
            <summary>
            Tells the bootstrap if we should initialize this module
            and add it to the module stack, if no will just unregister
            </summary>
        </member>
        <member name="M:Eggshell.IModule.OnReady">
            <summary>
            The module is now ready, has been added to the stack and
            other modules have been created. What should we do now?
            </summary>
        </member>
        <member name="M:Eggshell.IModule.OnUpdate">
            <summary>
            The application loop of a module, usually called every
            loop. Depends on the bootstrap. Use this for API callbacks
            and other constantly occuring events
            </summary>
        </member>
        <member name="M:Eggshell.IModule.OnFocused(System.Boolean)">
            <summary>
            A callback for when the application has changed its focus
            value. Gets called when the application looses or gains
            focus. Use this for pausing operations, if need be.
            </summary>
        </member>
        <member name="M:Eggshell.IModule.OnShutdown">
            <summary>
            Called when the application is shutting down, or the module
            is being removed from the stack. Make sure to unregister
            and dispose everything this module made from this function!
            </summary>
        </member>
        <member name="T:Eggshell.Module">
            <summary>
            Modules are automatically created by eggshell from the bootstrap
            on application startup (when you crack the egg). Modules allow incredibly
            easy dependency injection, as well as easily creating scalable applications 
            </summary>
        </member>
        <member name="P:Eggshell.Module.All">
            <summary>
            All the registered modules, that have been created by using the Create()
            function. You should use this for calling module only callbacks.
            </summary>
        </member>
        <member name="M:Eggshell.Module.Get``1">
            <summary>
            Try's to get a module by its type and will return it if it could
            find it in the registry. Will return null if it couldn't find it.
            </summary>
        </member>
        <member name="M:Eggshell.Module.TryGet``1(``0@)">
            <summary>
            Try's to get a module by its type and will return it if it could
            find it in the registry. Will return null if it couldn't find it.
            </summary>
        </member>
        <member name="M:Eggshell.Module.Create``1">
            <summary>
            Try's to create a module by its type and will add it to the registered
            list if it successes in doing so. Calls to this function will automatically
            be created by source generators, and invoked when the egg is cracked.
            </summary>
        </member>
        <member name="M:Eggshell.Module.OnRegister">
            <summary>
            Tells the bootstrap if we should initialize this module
            and add it to the module stack, if no will just unregister
            </summary>
        </member>
        <member name="M:Eggshell.Module.OnReady">
            <summary>
            The module is now ready, has been added to the stack and
            other modules have been created. What should we do now?
            </summary>
        </member>
        <member name="M:Eggshell.Module.OnUpdate">
            <summary>
            The application loop of a module, usually called every
            loop. Depends on the bootstrap. Use this for API callbacks
            and other constantly occuring events
            </summary>
        </member>
        <member name="M:Eggshell.Module.OnFocused(System.Boolean)">
            <summary>
            A callback for when the application has changed its focus
            value. Gets called when the application looses or gains
            focus. Use this for pausing operations, if need be.
            </summary>
        </member>
        <member name="M:Eggshell.Module.OnShutdown">
            <summary>
            Called when the application is shutting down, or the module
            is being removed from the stack. Make sure to unregister
            and dispose everything this module made from this function!
            </summary>
        </member>
        <member name="T:Eggshell.IRoutine">
            <summary>
            A IRoutine is a routine that can potentially have a UI representing it (Such as loading a map,
            connecting to a networked game, downloading an item while loading a map from the workshop).
            </summary>
        </member>
        <member name="P:Eggshell.IRoutine.Progress">
            <summary>
            The progress from 0 to 1 on how far done this routine is.
            </summary>load
        </member>
        <member name="P:Eggshell.IRoutine.Text">
            <summary>
            The text that should appear in the UI for when this request is loading.
            </summary>
        </member>
        <member name="M:Eggshell.IRoutine.Load(System.Action)">
            <summary>
            Run this item through the routine. Which means it could have a UI representing
            its current loading state.
            </summary>
        </member>
        <member name="M:Eggshell.IRoutine.Inject">
            <summary>
            Allows the injection of instructions before this instruction happens. Useful for preloading
            files, downloading maps, etc before actually loading the map
            </summary>
        </member>
        <member name="T:Eggshell.Routines">
            <summary>
            Routines might sound similar to coroutine, but they are completely different.
            Routines are a set of functions that fire based of a series of callbacks,
            allowing us to sequentially perform actions that usually are spanned across
            different frames, or different threads.
            </summary>
        </member>
        <member name="P:Eggshell.Routines.Progress">
            <summary>
            The progress of the current routine being processed. In the future this will be updated
            to be the progress of the whole routine.
            </summary>
        </member>
        <member name="P:Eggshell.Routines.Text">
            <summary>
            The help / loading text for the current routine that is being processed. Use this in
            your UI if you are using routines for loading maps.
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Start(System.Action,Eggshell.IRoutine[])">
            <summary>
            Starts a new routine based on an array of requests (params) with an optional callback
            parameter for when the routine is finished. 
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Start(System.Action,System.Func{Eggshell.IRoutine}[])">
            <summary>
            Starts a new routine based on an array of func requests (params) with an optional
            callback parameter for when the routine is finished. 
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Start(Eggshell.IRoutine[])">
            <summary>
            Starts a new routine based on an array of requests. Nothing special other than
            that. Its advised you use Func version where you can.
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Start(System.Func{Eggshell.IRoutine}[])">
            <summary>
            Starts a new routine based on an array of func requests. Will invoke the func when
            its time for it to inject.
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Create(System.Action{System.Action},System.String)">
            <summary>
            Creates a IRoutine based on an Action that has an Action as one of its parameters 
            (I know its weird) can be quite useful in a handful of scenarios (Such as prototyping
            a routine) 
            </summary>
        </member>
        <member name="M:Eggshell.Routines.Create(System.Threading.Tasks.Task,System.String)">
            <summary>
            Creates a IRoutine based on a task. The finish callback will be invoked once this task 
            has been completed. Progress depends on the task type.
            </summary>
        </member>
        <member name="P:Eggshell.Routines.Timing">
            <summary>
            The time it took for the last routine that was running to completely finish. This
            is mostly used as debugging information.
            </summary>
        </member>
        <member name="T:Eggshell.Project">
            <summary>
            Entry point to your Eggs, You'd want to
            inherit from this so Eggshell automatically
            creates your applications object. Make sure to
            call Crack in your programs entry point.
            </summary>
        </member>
        <member name="P:Eggshell.Project.Booted">
            <summary>
            Has Eggshell already been booted up and initialized? From
            a preexisting bootstrap?
            </summary>
        </member>
        <member name="P:Eggshell.Project.Bootstrap">
            <summary>
            The currently active bootstrap, that was cached from the
            crack methods. Bootstraps are used for low level control of
            eggshell.
            </summary>
        </member>
        <member name="M:Eggshell.Project.Crack">
            <summary>
            Uses Eggshells reflection system to find a
            bootstrap and uses that to initialize all
            modules created by source generators
            </summary>
        </member>
        <member name="M:Eggshell.Project.Crack(Eggshell.Bootstrap)">
            <summary>
            Initializes all Modules, created by
            source generators, through reflection
            </summary>
        </member>
        <member name="T:Eggshell.Reflection.OverrideAttribute">
            <summary>
            Overrides something in the source generator, it depends on the generator
            and the process its in. Will not work on most generators
            </summary>
        </member>
        <member name="T:Eggshell.Reflection.SkipAttribute">
            <summary>
            Skips a process in a source generator. Depends on the
            current processor and whats its doing.
            </summary>
        </member>
        <member name="T:Eggshell.Reflection.IBinding">
            <summary>
            IBinding is a binding to a library. Allows you to inject logic
            in to the library pipeline, as well as store custom library meta
            data for use in your project. (Such as the Archive Component)
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.IBinding.OnRegister(Eggshell.IObject)">
            <summary>
            Should we register this object to the library registry? If
            false, it'll destroy itself. If true we should be using this object 
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.IBinding.OnUnregister(Eggshell.IObject)">
            <summary>
            Cleanup any resources when this object gets removed from
            the registry (when it is deleted).
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.IBinding.OnCreate">
            <summary>
            What should we do when this object is created through the library
            system? Should we use a custom constructor? 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eggshell.Reflection.Function">
            <summary>
            Properties are used in libraries for defining variables
            that can be inspected and changed.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Info">
            <summary> 
            The MethodInfo that this function was generated for. 
            caching its meta data in the constructor.
            </summary>
        </member>
        <member name="F:Eggshell.Reflection.Function._info">
            <summary>
            The cached method info that is generated from
            <see cref="P:Eggshell.Reflection.Function.Info"/>.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Parent">
            <summary>
            Where did this function come from? (This will automatically
            pull function from this Library) - (Data is filled
            out by source generators)
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.ClassInfo">
            <summary>
            Function's IObject implementation for Library. as ironic
            as that sounds. Its used for getting meta about the Property
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.#ctor(System.String,System.String)">
            <summary>
            It isn't recommended that you create a function manually, as
            this is usually done through source generators.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Origin">
            <summary>
            The name of the function member that this eggshell property
            was generated from. Used when getting the property itself. 
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Name">
            <summary>
            The programmer friendly name of this function, that is used
            to generate a deterministic hash for the ID.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Id">
            <summary>
            The deterministic id created from <see cref="P:Eggshell.Reflection.Property.Name"/>,
            which is used in a Binary Tree / Sorted List to get functions
            by name.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Title">
            <summary>
            The nice looking name for this function. Used in UI as well as
            response from the user because they don't like looking at weird names
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Help">
            <summary>
            The help message that tells users about this function. This is usually
            generated from the XML documentation above a function.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.Group">
            <summary>
            The group that this function belongs to. This is used for getting
            all functions by group, as well as other functionality depending
            on the class that this function is from.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Function.IsStatic">
            <summary>
            Does this function require an instance accessor to be invoked?
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.GetDefaultArgs(System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            Gets the default arguments for a function parameter list,
            will use the inputted (in order of params) or the default
            value from the parameter.
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke(System.Object[])">
            <summary>
            Invokes this function statically.
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke">
            <summary>
            Invokes this function statically.
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke(Eggshell.IObject)">
            <summary>
            Invokes this function
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke``1(Eggshell.IObject)">
            <summary>
            Invokes this function with a return type of T
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke(Eggshell.IObject,System.Object[])">
            <summary>
            Invokes this function with an array of parameters
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Function.Invoke``1(Eggshell.IObject,System.Object[])">
            <summary>
            Invokes this function with an array of parameters and returns the
            type of T
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Members`1.Item(System.Int32)">
            <summary>
            Finds a member by its deterministic Id
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Members`1.Item(System.String)">
            <summary>
            Finds a member by its name
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property`1.Item(System.Object)">
            <summary>
            Tells the target instance to change the properties value
            by the input of "from".
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property`1.Value">
            <summary>
            A helper for setting and getting static variables to a value.
            Behind the scenes (if not overriden) will just get the indexer
            by null, and return the value based off of that.
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Property`1.op_Implicit(Eggshell.Reflection.Property{`0})~`0">
            <summary>
            A nice to have implicit operator to the target type, so if we're
            dealing with static properties, it's super easy to get them.
            </summary>
        </member>
        <member name="T:Eggshell.Reflection.Property">
            <summary>
            Properties are used in libraries for defining variables
            that can be inspected and changed. Every property has its
            own class generated for it. So it can be ultra optimised.
            You can also create dynamic properties that can be edited
            at runtime, which is incredibly useful in a handful
            of scenarios.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Info">
            <summary> 
            The PropertyInfo that this property was generated for. 
            This calls GetProperty, if it hasn't already.
            </summary>
        </member>
        <member name="F:Eggshell.Reflection.Property._info">
            <summary>
            The cached property info that is generated from
            <see cref="P:Eggshell.Reflection.Property.Info"/>.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Parent">
            <summary>
            Where did this property come from? (This will automatically
            pull properties and methods from this Library) - (Data is filled
            out by source generators)
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.ClassInfo">
            <summary>
            Property's IObject implementation for Library. as ironic
            as that sounds. Its used for getting meta about the Property
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Components">
            <summary>
            Components that have been attached to this property. Allows
            for easy storage of meta data, as well as property specific logic.
            </summary>
        </member>
        <member name="M:Eggshell.Reflection.Property.#ctor(System.String,System.String)">
            <summary>
            It isn't recommended that you create a property manually, as
            this is usually done through source generators.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Item(System.Object)">
            <summary>
            Tells the target instance to change the properties value
            by the input of "from".
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Value">
            <summary>
            A helper for setting and getting static variables to a value.
            Behind the scenes (if not overriden) will just get the indexer
            by null, and return the value based off of that.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Origin">
            <summary>
            The name of the property member that this eggshell property
            was generated from. Used when getting the property itself. 
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Name">
            <summary>
            The programmer friendly name of this property, that is used
            to generate a deterministic hash for the ID.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Id">
            <summary>
            The deterministic id created from <see cref="P:Eggshell.Reflection.Property.Name"/>,
            which is used in a Binary Tree / Sorted List to get properties
            by name.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Title">
            <summary>
            The nice looking name for this Property. Used in UI as well as
            response from the user because they don't like looking at weird names
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Help">
            <summary>
            The help message that tells users about this property. This is usually
            generated from the XML documentation above a property.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Group">
            <summary>
            The group that this property belongs to. This is used for getting
            all property by group, as well as other functionality depending
            on the class that this property is from.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.IsStatic">
            <summary>
            Does this property require an instance accessor to be changed?
            Used in the value setter.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.IsReadable">
            <summary>
            Does this property have a getter? False if not. This is usually
            generated by a source generator.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.IsAssignable">
            <summary>
            Does this property have a setter? False if not. Usually generated
            by a source generator.
            </summary>
        </member>
        <member name="P:Eggshell.Reflection.Property.Type">
            <summary>
            The backing type that this property is using.
            </summary>
        </member>
        <member name="T:Eggshell.ConstructorAttribute">
            <summary>
            Attribute that allows the definition of a custom constructor.
            Must return an IObject and Must have one parameter that takes in a Library.
            </summary>
        </member>
        <member name="T:Eggshell.GroupAttribute">
            <summary>
            Reflection Component for storing what group does this class belong too.
            Will override the Library.Group value.
            </summary>
        </member>
        <member name="T:Eggshell.HelpAttribute">
            <summary>
            Reflection Component that changes the Tile value on a Library or Property.
            </summary>
        </member>
        <member name="T:Eggshell.TitleAttribute">
            <summary>
            Reflection Component that changes the Tile value on a Library or Property.
            </summary>
        </member>
        <member name="T:Eggshell.Icon">
            <summary>
            An icon that represents a class. Useful for GUI where a file
            would usually need an icon (like .fbx or .wav, etc).
            </summary>
        </member>
        <member name="P:Eggshell.Icon.Id">
            <summary>
            What icon id should we load. (Depends on the application but
            it can be pulled from (for instance) google material icons)
            </summary>
        </member>
        <member name="P:Eggshell.Icon.Path">
            <summary>
            What icon file should we load from disk. If ID is set, it will
            prioritise that over the path.
            </summary>
        </member>
        <member name="T:Eggshell.Injectable">
            <summary>
            Allows a member to have injected components into it. Basically
            builds the source tree to allow custom logic to be injected
            </summary>
        </member>
        <member name="T:Eggshell.Order">
            <summary>
            Allows a member to have injected components into it. Basically
            builds the source tree to allow custom logic to be injected
            </summary>
        </member>
        <member name="P:Eggshell.Order.Value">
            <summary>
            The value that was created by the attribute that signifies
            what order this class or what ever should be in.
            </summary>
        </member>
        <member name="T:Eggshell.LibraryAttribute">
            <summary>
            Add this attribute to a class to add it to the library database,
            or to override its internal name for identification.
            </summary>
        </member>
        <member name="T:Eggshell.Libraries">
            <summary>
            Libraries is used for handling every library instance. It is
            also responsible for caching libraries too. Its in its own
            class so we can decouple it, plus provide a wrapper / our own
            accessors to the database.
            </summary>
        </member>
        <member name="P:Eggshell.Libraries.Item(System.Int32)">
            <summary>
            Finds a library by its deterministic Id, which is generated
            at compile time, from the classroom
            </summary>
        </member>
        <member name="P:Eggshell.Libraries.Item(System.String)">
            <summary>
            Finds a library by its name, which that string gets converted
            converted to its deterministic int id (hashed string)
            </summary>
        </member>
        <member name="P:Eggshell.Libraries.Item(System.Type)">
            <summary>
            Finds a library by its type, where it just does a linq operation to
            find the first type that equals the one in the library
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.Find(System.Type)">
            <summary>
            This will find the library that holds this type. Or will
            find a type that is implementing an interface from the inputted
            type, (as confusing as that sounds). This is very helpful
            for finding types easily. As it handles interface logic
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.Find(System.Type,System.Func{Eggshell.Library,System.Boolean})">
            <summary>
            This will find the library that holds this type with an added
            search pattern, where you can cull results based on components
            or what ever. Or will find a type that is implementing an interface
            from the inputted type, (as confusing as that sounds).
            This is very helpful for finding types easily.
            As it handles interface logic
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.Find``1">
            <inheritdoc cref="M:Eggshell.Libraries.Find(System.Type)"/>
        </member>
        <member name="M:Eggshell.Libraries.Find``1(System.Func{Eggshell.Library,System.Boolean})">
            <inheritdoc cref="M:Eggshell.Libraries.Find(System.Type,System.Func{Eggshell.Library,System.Boolean})"/>
        </member>
        <member name="M:Eggshell.Libraries.With``1">
            <summary>
            Gets all Components of T from every library
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.With``1(System.Func{Eggshell.Library,System.Boolean})">
            <summary>
            Gets all Components of T from every library, following a search
            pattern.
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.Has``1">
            <summary>
            Gets all Libraries with the given components
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.Has``1(System.Func{Eggshell.Library,System.Boolean})">
            <summary>
            Gets all Libraries with the given components, following a search
            pattern.
            </summary>
        </member>
        <member name="M:Eggshell.Libraries.All``1">
            <summary>
            This will get all libraries where they are a subclass of
            the type T, or will get types that implement the inputted
            interface. 
            </summary>
        </member>
        <member name="T:Eggshell.Library">
            <summary>
            Libraries are used for storing meta data on a type, this includes
            Title, Name, Group, Icons, etc. You can also add your own data
            using components. We can do a lotta cool and performant
            shit because of this. Such as easily doing C# / C++ calls.
            </summary>
        </member>
        <member name="P:Eggshell.Library.Info">
            <summary>
            The type this library was generated for, caching
            its meta data in the constructor. 
            </summary>
        </member>
        <member name="P:Eggshell.Library.Parent">
            <summary>
            What is this library inherited from. (This will automatically
            pull properties and methods from this Library) - (Data is filled
            out by source generators)
            </summary>
        </member>
        <member name="P:Eggshell.Library.Children">
            <summary>
            What is using this Library for inheritance. (Data is filled
            out by source generators)
            </summary>
        </member>
        <member name="P:Eggshell.Library.ClassInfo">
            <summary>
            Library's IObject implementation for Library. as ironic
            as that sounds. Its used for getting meta about Library
            </summary>
        </member>
        <member name="P:Eggshell.Library.Components">
            <summary>
            Components are added meta data onto that library, this can
            include icons, company, stylesheet, etc. They allow us
            to do some really crazy cool shit
            </summary>
        </member>
        <member name="P:Eggshell.Library.Properties">
            <summary>
            Properties are variables that the library owns. This is
            usually mutable value types if the property has a setter
            </summary>
        </member>
        <member name="P:Eggshell.Library.Functions">
            <summary>
            Functions are tasks that the library does broken up into
            groups so its easier to digest how a program works.
            </summary>
        </member>
        <member name="M:Eggshell.Library.#ctor(System.String,System.Int32,System.Type,Eggshell.Library)">
            <summary>
            It isn't recommended that you create the library manually, as
            this is usually done through source generators.
            </summary>
        </member>
        <member name="M:Eggshell.Library.#ctor(System.String,System.Type,Eggshell.Library)">
            <summary>
            It isn't recommended that you create the library manually, as
            this is usually done through source generators. This will automatically
            generate an id for the library, based off the name (hashed) 
            </summary>
        </member>
        <member name="M:Eggshell.Library.Create">
            <summary>
            Creates an IObject, this just does some sanity checking before
            calling the internal Construct() method, which can be overridden
            or uses a constructor attribute.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Create``1">
            <summary>
            Creates a type of T, this just does some sanity checking before
            calling the internal Construct() method, which can be overridden
            or uses a constructor attribute.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Construct">
            <summary>
            Constructs this IObject, can be overridden to provide custom logic.
            such as using a custom constructor, or setting off events when
            this library has been constructed. Use wisely!
            </summary>
        </member>
        <member name="M:Eggshell.Library.OnRegister(Eggshell.IObject)">
            <summary>
            A Callback for when an object is created and registered
            to this library. Incredibly useful for setting up instanced
            based callbacks, as well as keeping track of instances.
            </summary>
        </member>
        <member name="M:Eggshell.Library.OnUnregister(Eggshell.IObject)">
            <summary>
            A Callback for when an object is trying to be unregistered
            to this library. Incredibly useful for setting up instanced
            based callbacks, as well as keeping track of instances.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Inherits``1">
            <summary>
            Checks to see if this library inherits from T, useful for making
            sure you are casting to the right type.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Inherits(System.Type)">
            <summary>
            Checks to see if this library inherits from T, useful for making
            sure you are casting to the right type.
            </summary>
        </member>
        <member name="P:Eggshell.Library.Name">
            <summary>
            The programmer friendly name of this type, that is used
            to generate a deterministic hash for the ID.
            </summary>
        </member>
        <member name="P:Eggshell.Library.Id">
            <summary>
            The deterministic id created from <see cref="P:Eggshell.Library.Name"/>,
            which is used in a Binary Tree / Sorted List to get the library
            by name, and also is used for type checking for compiled data.
            </summary>
        </member>
        <member name="P:Eggshell.Library.Title">
            <summary>
            The nice looking name for this library. Used in UI as well as
            response from the user if they don't like looking at weird names
            </summary>
        </member>
        <member name="P:Eggshell.Library.Group">
            <summary>
            The group that this library belongs to. This is used for getting
            all libraries, as well as other functionality depending on the class
            that is inherited from a specific type (like asset)
            </summary>
        </member>
        <member name="P:Eggshell.Library.Help">
            <summary>
            The help message that tells users about this library. This is usually
            generated from the XML documentation above a type. Make sure your classes
            are documented so they are readable by both programmers and people who use
            your application!
            </summary>
        </member>
        <member name="P:Eggshell.Library.Database">
            <summary>
            Database for Library Records. Allows the access of all records.
            Use extension methods to add functionality to database access.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Register(Eggshell.IObject)">
            <summary>
            Registers the target object with the Library.
            Which allows it to receive instance callbacks and
            returns its library instance.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Unregister(Eggshell.IObject)">
            <summary>
            Cleans up IObject object, removes it from instance
            callback database so the garbage collector picks it up.
            </summary>
        </member>
        <member name="M:Eggshell.Library.Create``1(Eggshell.Library)">
            <summary> <inheritdoc cref="M:Eggshell.Library.Create"/> and returns T </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Log(System.String)">
            <summary>
            Logs a generic string straight to the active eggshell terminal logger. Will automatically
            get stripped if not in debug mode. 
            </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Entry``1(Eggshell.Diagnostics.ILogger,``0,System.String,System.String)">
            <summary>
            Adds a custom entry to the log output, Useful for debug callbacks to the steamworks api
            or any custom framework that has its own logger, and you need to add a custom label to it.
            </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Info``1(Eggshell.Diagnostics.ILogger,``0,System.String)">
            <summary>
            Adds a verbose info log to the log output. These are automatically stripped from your
            application if you're not doing a debug build.
            </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Warning``1(Eggshell.Diagnostics.ILogger,``0,System.String)">
            <summary>
            Adds a warning log to the log output. These are automatically stripped from your
            application if you're not doing a debug build. (Might change in the future)
            </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Error``1(Eggshell.Diagnostics.ILogger,``0,System.String)">
            <summary>
            Adds an error log to the log output. These won't be stripped from your application
            depending on the build type.
            </summary>
        </member>
        <member name="M:Eggshell.LoggerExtensions.Exception(Eggshell.Diagnostics.ILogger,System.Exception)">
            <summary>
            Adds an exception log to the log output. These won't be stripped from your application
            depending on the build type.
            </summary>
        </member>
        <member name="T:Eggshell.Terminal">
            <summary>
            Eggshell's core Debugging Library. Has support for
            logging, commands, overlays, and other utility features.
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.Command">
            <summary>
            Command Console. Use Run(string, object[]) to run a command.
            Your game can have its own Console provider.
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.Log">
            <summary>
            Add your own extension methods if need be, since this is an
            instanced class. Usually controlled by the bootstrap
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.Overlays">
            <summary>
            Overlays are things rendered over everything that represent
            debug information. This is usually null and depends on what the
            bootstrap does to initialize it.
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.IsDebug">
            <summary>
            Returns true if the instance was launched in developer mode,
            meaning there was a launch arg of -dev.
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.IsHeadless">
            <summary>
            Was the running process launched in a headless way (meaning no
            graphics)? Generated by the command line arguments
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.IsEditor">
            <summary>
            Returns true if the instance was launched in some sort of editor
            that can be used to edit assets and compile them. Set by the bootstrap
            (Such as launching Eggshell in the Unity Editor)
            </summary>
        </member>
        <member name="P:Eggshell.Terminal.Report">
            <summary>
            Should we report the stopwatch logs, or any other terminal
            specific things.
            </summary>
        </member>
        <member name="M:Eggshell.Terminal.Stopwatch(System.String,System.Boolean)">
            <summary>
            Runs a stopwatch on a IDisposable Scope. Use this in a using() expression
            to record how long it took to execute that code block.
            </summary>
        </member>
        <member name="T:Eggshell.Operator`1">
            <summary>
            An operator is a operation that is performed in the editor. Operators
            can be searched for in the editor is well. It is also recommended you
            use operators for tools that do actions / operations. This operator
            can have a callback.
            </summary>
        </member>
        <member name="T:Eggshell.Operator">
            <summary>
            An operator is a operation that is performed in the editor. Operators
            can be searched for in the editor is well. It is also recommended you
            use operators for tools that do actions / operations.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run(System.String)">
            <summary>
            Runs an operator based off its Library name. Not caring about
            any callback that it could potentially have.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run``1(System.String,``0)">
            <summary>
            Runs an operator based off its Library name, with a delegate
            generic arg, representing the callback that is invoked.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run(System.String,System.Action)">
            <summary>
            Runs an operator based off its Library name, with a predefined
            action which represents the callback.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run``1(System.String,System.Action{``0})">
            <summary>
            Runs an operator based off its Library name, with a predefined
            action with the generic args based off the ones fed through the
            method, which represents the callback.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run``2(System.String,System.Action{``0,``1})">
            <summary>
            Runs an operator based off its Library name, with a predefined
            action with the generic args based off the ones fed through the
            method, which represents the callback.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Run``3(System.String,System.Action{``0,``1,``2})">
            <summary>
            Runs an operator based off its Library name, with a predefined
            action with the generic args based off the ones fed through the
            method, which represents the callback.
            </summary>
        </member>
        <member name="M:Eggshell.Operator.Find``1(System.String)">
            <summary>
            Finds an operator based off the inputted name, creates it and
            returns the arg of T. So you can manually invoke it.
            </summary>
        </member>
        <member name="T:Eggshell.Assert">
            <summary>
            This class is a helper class for throwing exceptions
            when an operation is invalid.
            </summary>
        </member>
        <member name="T:Eggshell.EMath">
            <summary>
            EMath, meaning Eggshell Math.
            </summary>
        </member>
    </members>
</doc>
